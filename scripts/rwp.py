#!/usr/bin/env python

# Example of command line execution using rosrun:
# rosrun random_waypoint rwp.py _velocity:=0.5 _max_angle:=60 _xmin:=-10 _xmax:=15 _ymin:=-10 _ymax:=15

import rospy
import time

# import the Twist message
from geometry_msgs.msg import Twist
# import the Odometry message
from nav_msgs.msg import Odometry
from rospy.client import get_param
# import to send out data for position display
from std_msgs.msg import Float32MultiArray
import tf
import numpy as np
import sys
# imports for the ground truth in Gazebo simulations
from gazebo_msgs.srv import GetModelState
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.msg import ModelState
# http://docs.ros.org/api/gazebo_msgs/html/srv/GetModelState.html


class RandomWaypoint():
    def __init__(self):
        rospy.init_node('random_waypoint_controller',anonymous=False)

        print('RWP: start!')

        # this is necessary in the multi-robot version, where in the launch file
        # each (identical) robot gets a different namespace, such that same named
        # topics (.e.g, cmd_vel) are distinguished among the robots
        self.ns = rospy.get_namespace()
        print('RWP namespace:', rospy.get_namespace())

        # this nexessary in the multi-robot version to assign a unique id to
        # the message data from each robot running an RWP controller
        self.float_id = np.random.uniform()
        print ('My float id:', self.float_id)
        
        # Just to wait that Gazebo is up and giving the clock
        rospy.sleep(3)

        rospy.on_shutdown(self.shutdown)

        # Create a Publisher object, that will publish on the cmd_vel topic
        # to which the robot (real or simulated) is a subscriber
        velocity_topic = self.ns + 'cmd_vel'
        print(velocity_topic)
        self.velocity_pub = rospy.Publisher(velocity_topic, Twist, queue_size=5)

        # Creates a var of msg type Twist for velocity
        self.velocity = Twist()

        # Creates a var of msg type Odometry for position
        self.position = Odometry()   

        # Set a publish velocity rate of in Hz
        rate = rospy.get_param('/rate', 200)
        self.rate = rospy.Rate(rate)

        # the robot_model must correspond to the name generated by the spawn() service
        # in gazebo (in the launch file) when the robot has been created
        self.robot_model = rospy.get_param('~robot_name', 'turtlebot3_waffle_pi')
        print ('Robot model:', self.robot_model)

        print('Starting ground truth service ...')
        self.start_ground_truth_service()

        print('... done!')

        # initial settings
        self.at_waypoint = True
        self.at_edge_ = False
        self.traveled_distance = 0.0
        self.wp_distance = 0.0

        self.velocity.linear.y = 0.0
        self.velocity.angular.z = 0.0
        
        self.x = self.x_last = -999
        self.y = self.y_last = -999
        self.yaw = -999

        # get the robot pose from the odometry topic
        self.odom_sub = rospy.Subscriber(self.ns + 'odom', Odometry, self.callback_odometry, queue_size=1)
        
        # create a publisher to notify the sensor when reaching the destination
        self.sensor_pub = rospy.Publisher(self.ns + 'sensor',Odometry,queue_size=1)

        # set up number of robots
        self.robot_id = rospy.get_param('~id',1)
        print(self.robot_id)
        self.num_of_robots = rospy.get_param('/number_of_robots',1)
        print(self.num_of_robots)
        self.collision_tolerance = rospy.get_param('/collision_tolerance',0.5)
        print(self.collision_tolerance)
        
        # read the parameters for the RWP model
        self.pause_time = rospy.get_param('~pause_time', 2.0)
        self.max_distance = rospy.get_param('~max_travel_distance', 5)
        self.min_distance = rospy.get_param('~min_travel_distance', 1.5)
        self.max_angle = np.radians(rospy.get_param('~max_angle', 15))
        self.v = rospy.get_param('~velocity', 0.25)
        # the bounded region where the robot is allowed to move
        self.bounding_box = [ rospy.get_param('~xmin', -10), rospy.get_param('~ymin', -10),
        rospy.get_param('~xmax', 10), rospy.get_param('~ymax', 10) ]

        
        
        # wait for an input from the odometry topic
        print ('Wait for first odometry data ...')
        while ((self.x == -999) or (self.y == -999) or (self.yaw == -999)):
            self.rate.sleep()
        print('... done!')
        
        # check if the robot is inside the allowed region
        if self.at_edge():
            print('Robot is placed outside of the allowed area!')
            self.shutdown()
            sys.exit()
        
        print('Parameter values - v: {:.2f}, min_distance: {:.2f}, '
        'max_distance {:.2f}, max_angle: {:.2f}, '
        'pause_time: {:.2f}, bounding_box: {}\n'.format(self.v,
        self.min_distance,
        self.max_distance,
        self.max_angle,
        self.pause_time,
        self.bounding_box))
        print ("Initial Pose: ({:.2f}, {:.2f}) {:.2f}".format(self.x, self.y, self.yaw))
        
        # send data to show_path_and_infomap() for path visualization
        self.show_path = rospy.get_param('~show_path', 'False')
        if self.show_path:
            topic_followed_path = "/trajectory" # used by show_path_and_infomap node
            self.trajectory_pub = rospy.Publisher(topic_followed_path,
                                    Float32MultiArray, queue_size=10)
        
        # set the random seed
        seed = rospy.get_param('~rnd_seed', 111111)
        if seed == 111111:
            np.random.seed()
        else:
            np.random.seed(seed)

    def rwp(self):
        rospy.sleep(1)
        cnt = 0
        while not rospy.is_shutdown():
            # this is a hardcode value, can be changed! Just to avoid to have too much
            # output in the terminal
            if not (cnt % 150) and 0:
                self.print_status()
            cnt += 1
            #sys.stdout.flush()      
            
            # when near the edge, stop the motion, reset the waypoint, set the flag
            # to define a new waypoint inside
            if self.at_edge():
                print ('---> [{:.3f}] At edge ({:.3f}, {:.3f}) ({:.4f})'.format(rospy.get_time(),
                self.x, self.y,
                self.yaw))
                self.escape_edge()
                self.at_edge_ = True

            if self.check_colision():
                # need to stop to avoid a collision

                print("Avoiding Collision!!")

                # save previous velocity and change velocity to 0
                old_linear_x = self.velocity.linear.x
                self.velocity.linear.x = 0

                old_angular_z = self.velocity.angular.z
                self.velocity.angular.z = 0
                
                for i in range(10):
                    self.velocity_pub.publish(self.velocity)
                
                # wait for other robot to pass
                rospy.sleep(5)

                # restore old velocity
                self.velocity.linear.x = old_linear_x
                self.velocity.angular.z = old_angular_z
                
                self.velocity_pub.publish(self.velocity)

            
            # core of the controller, where a new waypoint is defined
            if (self.at_waypoint) or (self.at_edge_):
                self.velocity.linear.x = 0.0
                for i in range(10): # 10 repetitions to be sure that velocity goes to zero!
                    self.velocity_pub.publish(self.velocity)

                # At a waypoint the robots stops for a while (pause_time), a more meaningful
                # behavior can be implemented (e.g., sampling data)
                if self.at_waypoint:
                    print ('[{:.3f}] At waypoint ({:.3f}, {:.3f}) - Pausing ...'.format(rospy.get_time(),
                    self.x, self.y))
                    self.at_waypoint = False
                    rospy.sleep(self.pause_time)
                    self.notify_sensor()
                    print ('[{:.3f}] After pausing ({:.3f}, {:.3f})'.format(rospy.get_time(),
                    self.x, self.y))
                else: # the robot is near an edge
                    print ('New waypoint after bouncing back from edge ...')
                    self.at_edge_ = False
                # define the new waypoint by distance and angle to rotate
                # the angle is sampled first and the rotation is executed
                angle = np.radians(np.random.uniform(-self.max_angle, self.max_angle))
                self.rotate(angle)
                rospy.sleep(0.3) # to let the rotation complete smoothly
                # the distance is sampled
                self.wp_distance = np.random.uniform(self.min_distance, self.max_distance)
                # the next target waypoint is defined based on current pose and sample angle/distance
                self.wp_target = [self.x + (self.wp_distance * np.cos(self.yaw)),
                self.y + (self.wp_distance * np.sin(self.yaw))]
                # adapt the target waypoint to ensure it is in the allowed region
                self.keep_target_in_bounding_box()
                self.print_status()
                # reset the traveled distance (to the target)
                self.traveled_distance = 0.0
                # set the new starting point as the current one
                self.start = (self.x, self.y)
                print ('\n===> [{:.3f}] New waypoint at distance {:.3f}, '
                'angle {:.4f} -> ({:.3f}, {:.3f})'.format(rospy.get_time(), self.wp_distance,
                np.degrees(angle), self.wp_target[0],
                self.wp_target[1]))
                # set and publish the linear velocity for moving to target
                self.velocity.linear.x = self.v
                self.velocity.linear.y = 0.0
                self.velocity.angular.z = 0.0
                self.velocity_pub.publish(self.velocity)
            
            # measure the distance traveled so far from start to target, declare WP reached if the
            # distance exceeds expcted WP distance
            self.traveled_distance = self.distance_L2( [self.x, self.y], self.start )
            if self.traveled_distance >= self.wp_distance:
                #print 'WP reached'
                self.at_waypoint = True
                self.velocity.linear.x = 0.0
                self.velocity_pub.publish(self.velocity)

            # if the path is being displayed graphically, publish path data
            if self.show_path:
                self.publish_path()
            # keep going on!
            self.rate.sleep()

    def check_colision(self):
        current_id = self.robot_id
        num_of_robots = self.num_of_robots
        collision_tolerance = self.collision_tolerance
        # only check robots with a higher id, since we only stop if a robot
        # with a higher id is close
        for other_robot in range(current_id+1,num_of_robots+1):
            robot_param_name = '/R'+str(other_robot)+'/rwp/'
            other_x = rospy.get_param(robot_param_name+'x',-5)
            other_y = rospy.get_param(robot_param_name+'y',5)

            if self.distance_L2([self.x,self.y],[other_x,other_y]) < collision_tolerance:
                return True
        return False

    
    def at_edge(self):
        tolerance = 0.5
        if (self.x < self.bounding_box[0] + tolerance) or\
        (self.x > self.bounding_box[2] - tolerance) or\
        (self.y < self.bounding_box[1] + tolerance) or\
        (self.y > self.bounding_box[3] - tolerance):
            return True
        else:
            return False

    def keep_target_in_bounding_box(self):
        for i in [0,1]:
            if self.wp_target[i] < self.bounding_box[i]:
                self.wp_target[i] = self.bounding_box[i]
            if self.wp_target[i] > self.bounding_box[i+2]:
                self.wp_target[i] = self.bounding_box[i+2]
    
    def rotate(self, angle):
        # Error > 0 --> counter-clock-wise rotation is required
        ccw = 1
        cw = -1
        max_omega = 1
        if angle > 0:
            omega = ccw * max_omega
        else:
            omega = cw * max_omega
        
        current_yaw = self.yaw
        self.velocity.linear.x = 0.0
        self.velocity.angular.z = omega
        
        tolerance = abs(0.01 * angle) # let's stop little before, 1% of the angle
        target_angle = abs(angle) - tolerance
        while abs(self.yaw - current_yaw) < target_angle:
            #print 'Start Yaw', current_yaw, 'New yaw', self.yaw, 'Angle', angle
            self.velocity_pub.publish(self.velocity)
            rospy.Rate(300).sleep()
        
        self.velocity.linear.x = 0.0
        self.velocity.angular.z = 0.0
        
        for i in range(5):
            self.velocity_pub.publish(self.velocity)

    def sum_of_two_angles(self, a1, a2):
        #atan2(y1, x1) +- atan2(y2, x2) = atan2(y1*x2 +- y2*x1, x1 * x2 -+ y1*y2)
        x1 = np.cos(a1)
        y1 = np.sin(a1)
        x2 = np.cos(a2)
        y2 = np.sin(a2)
        sum_a1_a2 = np.arctan2(y1*x2 + y2*x1, x1*x2 - y1*y2)
        return sum_a1_a2

    def difference_of_two_angles(self, a1, a2):
        #atan2(y1, x1) +- atan2(y2, x2) = atan2(y1*x2 +- y2*x1, x1 * x2 -+ y1*y2)
        x1 = np.cos(a1)
        y1 = np.sin(a1)
        x2 = np.cos(a2)
        y2 = np.sin(a2)
        sum_a1_a2 = np.arctan2(y1*x2 - y2*x1, x1*x2 + y1*y2)
        return sum_a1_a2

    def get_angle_to_target_point(self, target_x, target_y):
        #atan2(y1, x1) +- atan2(y2, x2) = atan2(y1*x2 +- y2*x1, x1 * x2 -+ y1*y2)
        #direction_to_target = np.arctan2((target_y - self.y), (target_x - self.x))
        y1 = (target_y - self.y)
        x1 = (target_x - self.x)
        print('\tAngle to target: ', np.degrees(np.arctan2(y1, x1)))
        # robot orientations
        (y2, x2) = (np.sin(self.yaw), np.cos(self.yaw))
        print('\tRobot yaw: ', np.degrees(np.arctan2(y2, x2)))
        angle_to_target = np.arctan2(y1*x2 - y2*x1, x1*x2 + y1*y2)
        print('\tAngle to rotate to reach target: ', np.degrees(angle_to_target))

        return angle_to_target
    
    def escape_edge(self):

        angle_to_center = self.get_angle_to_target_point(0.0, 0.0)
        
        self.rotate(angle_to_center)
        
        self.velocity.linear.x = 0.5 * self.v
        self.velocity.linear.y = 0.0
        self.velocity.angular.z = 0.0
        
        self.edge_x = self.x
        self.edge_y = self.y
        
        cnt = 0
        escape_distance = 1
        while self.distance_L2( [self.edge_x, self.edge_y], [self.x, self.y] ) < escape_distance:
            self.velocity_pub.publish(self.velocity)
            rospy.Rate(50).sleep()
    
        self.velocity.linear.x = 0.0
        self.velocity_pub.publish(self.velocity)

    # update the pose using ground truth!
    def update_pose(self):
        self.x, self.y = self.get_position_ground_truth(self.robot_model)
        rospy.set_param('~x',self.x)
        rospy.set_param('~y',self.y)
        siny, cosy = self.get_orientation_ground_truth(self.robot_model)
        self.yaw = np.arctan2(siny, cosy)

    # 'ideal': the pose is update with update_pose(), i.e., ground truth
    # however, commenting the call to update_pose() and uncommenting the
    # three odometry lines would make use of real data / estimation
    def callback_odometry(self, msg):
        self.x_last = self.x
        self.y_last = self.y
        # ground truth, ideal world
        self.update_pose()
        # uncomment these lines to get the real data
        #self.x = msg.pose.pose.position.x
        #self.y = msg.pose.pose.position.y
        #self.yaw = msg.pose.pose.position.x = self.quaternion_to_euler(msg)

    def notify_sensor(self):
        self.position.pose.pose.position.x = self.x
        self.position.pose.pose.position.y = self.y
        self.sensor_pub.publish(self.position)

    def print_status(self):
        print("\t[{:.3f}] Pose: {:.2f}, {:.2f} {:.2f}".format(rospy.get_time(), self.x, self.y, self.yaw))
        print("\tDistance to WP: {:5.2f}".format(self.wp_distance - self.traveled_distance))
    
    def quaternion_to_euler(self, msg):
        quaternion = (msg.pose.pose.orientation.x, msg.pose.pose.orientation.y,
                        msg.pose.pose.orientation.z, msg.pose.pose.orientation.w)
        (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(quaternion)
        #print "Roll: %5.2f Pitch: %5.2f Yaw: %5.2f" % (roll, pitch, yaw)
        return yaw
    
    def publish_path(self):
        #x, y = self.get_position_ground_truth(self.robot_model)
        #siny, cosy = self.get_orientation_ground_truth(self.robot_model)
        #yaw = np.arctan2(siny, cosy)
        self.trajectory_pub.publish(Float32MultiArray(data=[self.float_id,
        self.x, self.y, self.yaw, rospy.get_time(),
        self.wp_target[0], self.wp_target[1] ] ))

    def distance_L2(self, u, v):
        return np.sqrt( (u[0] - v[0])*(u[0] - v[0]) + (u[1] - v[1])*(u[1] - v[1]) )
    
    def start_ground_truth_service(self):
        rospy.wait_for_service("/gazebo/get_model_state")
        self.get_ground_truth = rospy.ServiceProxy("/gazebo/get_model_state", GetModelState)
        print('Ground truth service started!')
    
    def get_position_ground_truth(self, robot_model):
        return ( (self.get_ground_truth(robot_model, "world")).pose.position.x,
                (self.get_ground_truth(robot_model, "world")).pose.position.y )
        

    def get_orientation_ground_truth(self, robot_model):
        orientation = (self.get_ground_truth(robot_model, "world")).pose.orientation
        q = (orientation.x, orientation.y, orientation.z, orientation.w)
        siny = 2.0 * (q[3] * q[2] + q[0] * q[1])
        cosy = 1.0 - 2.0 * (q[1]**2 + q[2]**2)
        #yaw = atan2(siny, cosy)
        #(roll, pitch, yaw) = tf.transformations.euler_from_quaternion(q)
        return (siny, cosy)

    def shutdown(self):
        # stop turtlebot
        rospy.loginfo("Stop TurtleBot")
        self.velocity.linear.x = 0.0
        self.velocity.angular.z = 0.0
        self.velocity_pub.publish(self.velocity)

        # sleep just makes sure TurtleBot receives the stop command prior to shutting down
        rospy.sleep(1)

if __name__ == '__main__':
    motion_controller = RandomWaypoint()
    motion_controller.rwp()
#except:
# rospy.loginfo("rwp node terminated")
